/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../deps/phoenix/priv/static/phoenix.esm.js":
/*!**************************************************!*\
  !*** ../deps/phoenix/priv/static/phoenix.esm.js ***!
  \**************************************************/
/*! exports provided: Channel, LongPoll, Presence, Serializer, Socket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Channel\", function() { return Channel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LongPoll\", function() { return LongPoll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Presence\", function() { return Presence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Serializer\", function() { return serializer_default; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Socket\", function() { return Socket; });\n// js/phoenix/utils.js\nvar closure = value => {\n  if (typeof value === \"function\") {\n    return value;\n  } else {\n    let closure2 = function () {\n      return value;\n    };\n    return closure2;\n  }\n};\n\n// js/phoenix/constants.js\nvar globalSelf = typeof self !== \"undefined\" ? self : null;\nvar phxWindow = typeof window !== \"undefined\" ? window : null;\nvar global = globalSelf || phxWindow || void 0;\nvar DEFAULT_VSN = \"2.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 1e4;\nvar WS_CLOSE_NORMAL = 1e3;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\nvar XHR_STATES = {\n  complete: 4\n};\n\n// js/phoenix/push.js\nvar Push = class {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || function () {\n      return {};\n    };\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  resend(timeout) {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n  send() {\n    if (this.hasReceived(\"timeout\")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    });\n  }\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response);\n    }\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n  reset() {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n  matchReceive({ status, response, _ref }) {\n    this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));\n  }\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel.off(this.refEvent);\n  }\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n    this.channel.on(this.refEvent, payload => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, { status, response });\n  }\n};\n\n// js/phoenix/timer.js\nvar Timer = class {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n};\n\n// js/phoenix/channel.js\nvar Channel = class {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.stateChangeRefs = [];\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n    this.stateChangeRefs.push(this.socket.onOpen(() => {\n      this.rejoinTimer.reset();\n      if (this.isErrored()) {\n        this.rejoin();\n      }\n    }));\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError(reason => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", `error ${this.topic}`, reason);\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, reason => callback(reason));\n  }\n  on(event, callback) {\n    let ref = this.bindingRef++;\n    this.bindings.push({ event, ref, callback });\n    return ref;\n  }\n  off(event, ref) {\n    this.bindings = this.bindings.filter(bind => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n    });\n  }\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  push(event, payload, timeout = this.timeout) {\n    payload = payload || {};\n    if (!this.joinedOnce) {\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n    }\n    let pushEvent = new Push(this, event, function () {\n      return payload;\n    }, timeout);\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset();\n    this.joinPush.cancelTimeout();\n    this.state = CHANNEL_STATES.leaving;\n    let onClose = () => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\n    };\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n    leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n    leavePush.send();\n    if (!this.canPush()) {\n      leavePush.trigger(\"ok\", {});\n    }\n    return leavePush;\n  }\n  onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false;\n    }\n    if (joinRef && joinRef !== this.joinRef()) {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", { topic, event, payload, joinRef });\n      return false;\n    } else {\n      return true;\n    }\n  }\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\n    if (payload && !handledPayload) {\n      throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n    }\n    let eventBindings = this.bindings.filter(bind => bind.event === event);\n    for (let i = 0; i < eventBindings.length; i++) {\n      let bind = eventBindings[i];\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n};\n\n// js/phoenix/ajax.js\nvar Ajax = class {\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new global.XDomainRequest();\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n    } else {\n      let req = new global.XMLHttpRequest();\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n    }\n  }\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.onprogress = () => {};\n    req.send(body);\n  }\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    req.setRequestHeader(\"Content-Type\", accept);\n    req.onerror = () => {\n      callback && callback(null);\n    };\n    req.onreadystatechange = () => {\n      if (req.readyState === XHR_STATES.complete && callback) {\n        let response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.send(body);\n  }\n  static parseJSON(resp) {\n    if (!resp || resp === \"\") {\n      return null;\n    }\n    try {\n      return JSON.parse(resp);\n    } catch (e) {\n      console && console.log(\"failed to parse JSON response\", resp);\n      return null;\n    }\n  }\n  static serialize(obj, parentKey) {\n    let queryStr = [];\n    for (var key in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        continue;\n      }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n      let paramVal = obj[key];\n      if (typeof paramVal === \"object\") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n      }\n    }\n    return queryStr.join(\"&\");\n  }\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    return `${url}${prefix}${this.serialize(params)}`;\n  }\n};\n\n// js/phoenix/longpoll.js\nvar LongPoll = class {\n  constructor(endPoint) {\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function () {};\n    this.onerror = function () {};\n    this.onmessage = function () {};\n    this.onclose = function () {};\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.poll();\n  }\n  normalizeEndpoint(endPoint) {\n    return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n  }\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n  }\n  closeAndRetry() {\n    this.close();\n    this.readyState = SOCKET_STATES.connecting;\n  }\n  ontimeout() {\n    this.onerror(\"timeout\");\n    this.closeAndRetry();\n  }\n  poll() {\n    if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n      return;\n    }\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), resp => {\n      if (resp) {\n        var { status, token, messages } = resp;\n        this.token = token;\n      } else {\n        status = 0;\n      }\n      switch (status) {\n        case 200:\n          messages.forEach(msg => {\n            setTimeout(() => {\n              this.onmessage({ data: msg });\n            }, 0);\n          });\n          this.poll();\n          break;\n        case 204:\n          this.poll();\n          break;\n        case 410:\n          this.readyState = SOCKET_STATES.open;\n          this.onopen();\n          this.poll();\n          break;\n        case 403:\n          this.onerror();\n          this.close();\n          break;\n        case 0:\n        case 500:\n          this.onerror();\n          this.closeAndRetry();\n          break;\n        default:\n          throw new Error(`unhandled poll status ${status}`);\n      }\n    });\n  }\n  send(body) {\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), resp => {\n      if (!resp || resp.status !== 200) {\n        this.onerror(resp && resp.status);\n        this.closeAndRetry();\n      }\n    });\n  }\n  close(_code, _reason) {\n    this.readyState = SOCKET_STATES.closed;\n    this.onclose();\n  }\n};\n\n// js/phoenix/presence.js\nvar Presence = class {\n  constructor(channel, opts = {}) {\n    let events = opts.events || { state: \"presence_state\", diff: \"presence_diff\" };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function () {},\n      onLeave: function () {},\n      onSync: function () {}\n    };\n    this.channel.on(events.state, newState => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach(diff => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, diff => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  list(by) {\n    return Presence.list(this.state, by);\n  }\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  }\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState);\n    let joins = {};\n    let leaves = {};\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key];\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map(m => m.phx_ref);\n        let curRefs = currentPresence.metas.map(m => m.phx_ref);\n        let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0);\n        let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0);\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n  }\n  static syncDiff(state, diff, onJoin, onLeave) {\n    let { joins, leaves } = this.clone(diff);\n    if (!onJoin) {\n      onJoin = function () {};\n    }\n    if (!onLeave) {\n      onLeave = function () {};\n    }\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key];\n      state[key] = this.clone(newPresence);\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map(m => m.phx_ref);\n        let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0);\n        state[key].metas.unshift(...curMetas);\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      let refsToRemove = leftPresence.metas.map(m => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter(p => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function (key, pres) {\n        return pres;\n      };\n    }\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence);\n    });\n  }\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));\n  }\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// js/phoenix/serializer.js\nvar serializer_default = {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: { push: 0, reply: 1, broadcast: 2 },\n  encode(msg, callback) {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg));\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n      return callback(JSON.stringify(payload));\n    }\n  },\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload));\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n      return callback({ join_ref, ref, topic, event, payload });\n    }\n  },\n  binaryEncode(message) {\n    let { join_ref, ref, event, topic, payload } = message;\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    let view = new DataView(header);\n    let offset = 0;\n    view.setUint8(offset++, this.KINDS.push);\n    view.setUint8(offset++, join_ref.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, event.length);\n    Array.from(join_ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(topic, char => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(event, char => view.setUint8(offset++, char.charCodeAt(0)));\n    var combined = new Uint8Array(header.byteLength + payload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(payload), header.byteLength);\n    return combined.buffer;\n  },\n  binaryDecode(buffer) {\n    let view = new DataView(buffer);\n    let kind = view.getUint8(0);\n    let decoder = new TextDecoder();\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder);\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder);\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder);\n    }\n  },\n  decodePush(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let topicSize = view.getUint8(2);\n    let eventSize = view.getUint8(3);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: joinRef, ref: null, topic, event, payload: data };\n  },\n  decodeReply(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let refSize = view.getUint8(2);\n    let topicSize = view.getUint8(3);\n    let eventSize = view.getUint8(4);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n    offset = offset + refSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    let payload = { status: event, response: data };\n    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };\n  },\n  decodeBroadcast(buffer, view, decoder) {\n    let topicSize = view.getUint8(1);\n    let eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: null, ref: null, topic, event, payload: data };\n  }\n};\n\n// js/phoenix/socket.js\nvar Socket = class {\n  constructor(endPoint, opts = {}) {\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.establishedConnections = 0;\n    this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n    this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n    this.closeWasClean = false;\n    this.binaryType = opts.binaryType || \"arraybuffer\";\n    this.connectClock = 1;\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n    let awaitingConnectionOnPageShow = null;\n    if (phxWindow && phxWindow.addEventListener) {\n      phxWindow.addEventListener(\"pagehide\", _e => {\n        if (this.conn) {\n          this.disconnect();\n          awaitingConnectionOnPageShow = this.connectClock;\n        }\n      });\n      phxWindow.addEventListener(\"pageshow\", _e => {\n        if (awaitingConnectionOnPageShow === this.connectClock) {\n          awaitingConnectionOnPageShow = null;\n          this.connect();\n        }\n      });\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n    this.rejoinAfterMs = tries => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n      }\n    };\n    this.reconnectAfterMs = tries => {\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n      }\n    };\n    this.logger = opts.logger || null;\n    this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n    this.params = closure(opts.params || {});\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.vsn = opts.vsn || DEFAULT_VSN;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect());\n    }, this.reconnectAfterMs);\n  }\n  replaceTransport(newTransport) {\n    this.disconnect();\n    this.transport = newTransport;\n  }\n  protocol() {\n    return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n  }\n  endPointURL() {\n    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });\n    if (uri.charAt(0) !== \"/\") {\n      return uri;\n    }\n    if (uri.charAt(1) === \"/\") {\n      return `${this.protocol()}:${uri}`;\n    }\n    return `${this.protocol()}://${location.host}${uri}`;\n  }\n  disconnect(callback, code, reason) {\n    this.connectClock++;\n    this.closeWasClean = true;\n    this.reconnectTimer.reset();\n    this.teardown(callback, code, reason);\n  }\n  connect(params) {\n    this.connectClock++;\n    if (params) {\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n      this.params = closure(params);\n    }\n    if (this.conn) {\n      return;\n    }\n    this.closeWasClean = false;\n    this.conn = new this.transport(this.endPointURL());\n    this.conn.binaryType = this.binaryType;\n    this.conn.timeout = this.longpollerTimeout;\n    this.conn.onopen = () => this.onConnOpen();\n    this.conn.onerror = error => this.onConnError(error);\n    this.conn.onmessage = event => this.onConnMessage(event);\n    this.conn.onclose = event => this.onConnClose(event);\n  }\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  hasLogger() {\n    return this.logger !== null;\n  }\n  onOpen(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.open.push([ref, callback]);\n    return ref;\n  }\n  onClose(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.close.push([ref, callback]);\n    return ref;\n  }\n  onError(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.error.push([ref, callback]);\n    return ref;\n  }\n  onMessage(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.message.push([ref, callback]);\n    return ref;\n  }\n  onConnOpen() {\n    if (this.hasLogger()) this.log(\"transport\", `connected to ${this.endPointURL()}`);\n    this.closeWasClean = false;\n    this.establishedConnections++;\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.resetHeartbeat();\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n  }\n  heartbeatTimeout() {\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      if (this.hasLogger()) {\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n      }\n      this.abnormalClose(\"heartbeat timeout\");\n    }\n  }\n  resetHeartbeat() {\n    if (this.conn && this.conn.skipHeartbeat) {\n      return;\n    }\n    this.pendingHeartbeatRef = null;\n    clearTimeout(this.heartbeatTimer);\n    setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n  teardown(callback, code, reason) {\n    if (!this.conn) {\n      return callback && callback();\n    }\n    this.waitForBufferDone(() => {\n      if (this.conn) {\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n      }\n      this.waitForSocketClosed(() => {\n        if (this.conn) {\n          this.conn.onclose = function () {};\n          this.conn = null;\n        }\n        callback && callback();\n      });\n    });\n  }\n  waitForBufferDone(callback, tries = 1) {\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1);\n    }, 150 * tries);\n  }\n  waitForSocketClosed(callback, tries = 1) {\n    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1);\n    }, 150 * tries);\n  }\n  onConnClose(event) {\n    if (this.hasLogger()) this.log(\"transport\", \"close\", event);\n    this.triggerChanError();\n    clearTimeout(this.heartbeatTimer);\n    if (!this.closeWasClean) {\n      this.reconnectTimer.scheduleTimeout();\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n  }\n  onConnError(error) {\n    if (this.hasLogger()) this.log(\"transport\", error);\n    let transportBefore = this.transport;\n    let establishedBefore = this.establishedConnections;\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore);\n    });\n    if (transportBefore === this.transport || establishedBefore > 0) {\n      this.triggerChanError();\n    }\n  }\n  triggerChanError() {\n    this.channels.forEach(channel => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error);\n      }\n    });\n  }\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return \"connecting\";\n      case SOCKET_STATES.open:\n        return \"open\";\n      case SOCKET_STATES.closing:\n        return \"closing\";\n      default:\n        return \"closed\";\n    }\n  }\n  isConnected() {\n    return this.connectionState() === \"open\";\n  }\n  remove(channel) {\n    this.off(channel.stateChangeRefs);\n    this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef());\n  }\n  off(refs) {\n    for (let key in this.stateChangeCallbacks) {\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1;\n      });\n    }\n  }\n  channel(topic, chanParams = {}) {\n    let chan = new Channel(topic, chanParams, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  push(data) {\n    if (this.hasLogger()) {\n      let { topic, event, payload, ref, join_ref } = data;\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n    }\n    if (this.isConnected()) {\n      this.encode(data, result => this.conn.send(result));\n    } else {\n      this.sendBuffer.push(() => this.encode(data, result => this.conn.send(result)));\n    }\n  }\n  makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  sendHeartbeat() {\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\n      return;\n    }\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\n    this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n  }\n  abnormalClose(reason) {\n    this.closeWasClean = false;\n    if (this.isConnected()) {\n      this.conn.close(WS_CLOSE_NORMAL, reason);\n    }\n  }\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let { topic, event, payload, ref, join_ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef) {\n        clearTimeout(this.heartbeatTimer);\n        this.pendingHeartbeatRef = null;\n        setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n      }\n      if (this.hasLogger()) this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i];\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue;\n        }\n        channel.trigger(event, payload, ref, join_ref);\n      }\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        let [, callback] = this.stateChangeCallbacks.message[i];\n        callback(msg);\n      }\n    });\n  }\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c.isJoined() || c.isJoining()));\n    if (dupChannel) {\n      if (this.hasLogger()) this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n      dupChannel.leave();\n    }\n  }\n};\n\n//# sourceMappingURL=phoenix.esm.js.map\n\n//# sourceURL=webpack:///../deps/phoenix/priv/static/phoenix.esm.js?");

/***/ }),

/***/ "../deps/phoenix_html/priv/static/phoenix_html.js":
/*!********************************************************!*\
  !*** ../deps/phoenix_html/priv/static/phoenix_html.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent;\n    // IE<=9 Support\n    function CustomEvent(event, params) {\n      params = params || { bubbles: false, cancelable: false, detail: undefined };\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element, targetModifierKey) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        target = element.getAttribute(\"target\");\n\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n\n    if (target) form.target = target;else if (targetModifierKey) form.target = \"_blank\";\n\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function (e) {\n    var element = e.target;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true, \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element, e.metaKey || e.shiftKey);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n    if (message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();\n\n//# sourceURL=webpack:///../deps/phoenix_html/priv/static/phoenix_html.js?");

/***/ }),

/***/ "./css/app.css":
/*!*********************!*\
  !*** ./css/app.css ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./css/app.css?");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.css */ \"./css/app.css\");\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix_html */ \"../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! phoenix */ \"../deps/phoenix/priv/static/phoenix.esm.js\");\n/* harmony import */ var _sketchpad__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sketchpad */ \"./js/sketchpad.js\");\n\n\n\n\n\nlet socket = new phoenix__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"](\"/socket\", {\n  params: { token: window.userToken },\n  logger: function (kind, msg, data) {\n    console.log(`${kind}: ${msg}`, data);\n  }\n});\n\nlet App = {\n  init() {\n    socket.connect();\n\n    this.padChannel = socket.channel(\"pad:lobby\");\n    this.el = document.getElementById(\"sketchpad\");\n    this.pad = new _sketchpad__WEBPACK_IMPORTED_MODULE_3__[\"Sketchpad\"](this.el, window.userame);\n\n    this.bind();\n\n    this.padChannel.join().receive(\"ok\", resp => console.log(\"joined!\", resp)).receive(\"error\", resp => console.log(\"failed to join\", resp));\n  },\n\n  bindJason() {\n    let loginForm = document.getElementById(\"login-form\");\n    let usernameInput = document.getElementById(\"username-input\");\n    let jasonLoginBtn = document.getElementById(\"jason-login-btn\");\n\n    jasonLoginBtn.addEventListener(\"click\", e => {\n      console.log('logging in as jason');\n      e.preventDefault();\n      usernameInput.value = \"jason\";\n      loginForm.submit();\n    });\n  },\n\n  bind() {\n    this.pad.on(\"stroke\", data => this.padChannel.push(\"stroke\", data));\n\n    this.padChannel.on(\"stroke\", ({ user_id, stroke }) => {\n      this.pad.putStroke(user_id, stroke, { color: \"#000\" });\n    });\n\n    this.clearButton = document.getElementById(\"clear-button\");\n    this.exportButton = document.getElementById(\"export-button\");\n\n    this.clearButton.addEventListener(\"click\", e => {\n      e.preventDefault();\n      this.padChannel.push(\"clear\", {});\n    });\n\n    this.padChannel.on(\"clear\", () => this.pad.clear());\n\n    this.exportButton.addEventListener(\"click\", e => {\n      console.log('exporting!');\n      let win = window.open();\n      win.document.write(`<img src=\"${this.pad.getImageURL()}\" />`);\n    });\n\n    this.msgInput = document.getElementById(\"message-input\");\n    this.msgContainer = document.getElementById(\"messages\");\n\n    this.padChannel.on(\"new_message\", ({ user_id, body }) => {\n      this.msgContainer.innerHTML += `<b>${Object(_sketchpad__WEBPACK_IMPORTED_MODULE_3__[\"sanitize\"])(user_id)}</b>: ${Object(_sketchpad__WEBPACK_IMPORTED_MODULE_3__[\"sanitize\"])(body)}<br/>`;\n      this.msgContainer.scrollTop = this.msgContainer.scrollHeight;\n    });\n\n    addEventListener(\"keypress\", e => {\n      if (e.keyCode !== 13) return;\n\n      let body = this.msgInput.value;\n      this.msgInput.disabled = true;\n\n      let onOk = () => {\n        this.msgInput.disabled = false;\n        this.msgInput.value = \"\";\n      };\n\n      let onError = () => {\n        this.msgInput.disabled = false;\n      };\n\n      this.padChannel.push(\"new_message\", { body }).receive(\"ok\", onOk).receive(\"error\", onError).receive(\"timeout\", onError);\n    });\n  }\n};\n\nif (window.userToken !== \"\") {\n  App.init();\n} else {\n  console.log('no user token!');\n  App.bindJason();\n}\n\n//# sourceURL=webpack:///./js/app.js?");

/***/ }),

/***/ "./js/sketchpad.js":
/*!*************************!*\
  !*** ./js/sketchpad.js ***!
  \*************************/
/*! exports provided: sanitize, Sketchpad */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sanitize\", function() { return sanitize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sketchpad\", function() { return Sketchpad; });\n\nfunction map(obj, func) {\n  return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));\n}\n\nfunction mergeObjects(obj1, obj2) {\n  var obj3 = {};\n  var attrname;\n  for (attrname in obj1 || {}) {\n    if (obj1.hasOwnProperty(attrname)) {\n      obj3[attrname] = obj1[attrname];\n    }\n  }\n  for (attrname in obj2 || {}) {\n    if (obj2.hasOwnProperty(attrname)) {\n      obj3[attrname] = obj2[attrname];\n    }\n  }\n  return obj3;\n}\n\nfunction sanitize(str) {\n  let div = document.createElement(\"div\");\n  div.appendChild(document.createTextNode(str));\n  return div.innerHTML;\n}\n\nclass Sketchpad {\n\n  constructor(el, userId, opts) {\n    if (!el) {\n      throw new Error('Must pass in a container element');\n    }\n\n    this.el = el;\n    this.userId = userId;\n    this.opts = opts || {};\n    this.opts.aspectRatio = this.opts.aspectRatio || 1;\n    this.opts.width = this.opts.width || this.el.clientWidth;\n    this.opts.height = this.opts.height || this.opts.width * this.opts.aspectRatio;\n    this.opts.line = mergeObjects({\n      color: '#000',\n      size: 5,\n      cap: 'round',\n      join: 'round',\n      miterLimit: 10\n    }, this.opts.line);\n\n    this.users = mergeObjects(this.buildDefaultUsers(this.userId), this.opts.data);\n    this.events = {};\n    this.eventBuffer = null;\n    this.flushEventsEvery = 100;\n    this.eventTimer = setInterval(() => this.flushEvents(), this.flushEventsEvery);\n    this.undos = [];\n\n    // Boolean indicating if currently drawing\n    this.sketching = false;\n\n    // Create a canvas element\n    this.canvas = document.createElement('canvas');\n    this.setCanvasSize(this.opts.width, this.opts.height);\n    this.resizeTimer = null;\n    window.onresize = () => {\n      clearTimeout(this.resizeTimer);\n      this.resizeTimer = setTimeout(() => this.resize(this.el.clientWidth), 100);\n    };\n    el.appendChild(this.canvas);\n    this.context = this.canvas.getContext('2d');\n    // Event Listeners\n    this.canvas.addEventListener('mousedown', e => this.startLine(e));\n    this.canvas.addEventListener('touchstart', e => this.startLine(e));\n    this.canvas.addEventListener('mousemove', e => this.moveLine(e));\n    this.canvas.addEventListener('touchmove', e => this.moveLine(e));\n    this.canvas.addEventListener('mouseup', e => this.endLine(e));\n    this.canvas.addEventListener('mouseleave', e => this.endLine(e));\n    this.canvas.addEventListener('touchend', e => this.endLine(e));\n    this.fullRedraw();\n  }\n\n  flushEvents() {\n    if (this.eventBuffer) {\n      this.getEvents(\"stroke\").forEach(cb => cb(this.eventBuffer.stroke));\n      if (this.sketching) {\n        this.startLine(this.eventBuffer.event);\n      }\n      this.eventBuffer = null;\n    }\n  }\n\n  buildUser(userId, data) {\n    return data || { id: userId, strokes: [], lastPaintedIndex: 0 };\n  }\n\n  buildDefaultUsers(userId) {\n    let defaults = {};\n    defaults[userId] = this.buildUser(userId);\n    return defaults;\n  }\n\n  setCanvasSize(width, height) {\n    this.canvas.setAttribute('width', width);\n    this.canvas.setAttribute('height', height);\n    this.canvas.style.width = width + 'px';\n    this.canvas.style.height = height + 'px';\n  }\n\n  getCanvasSize() {\n    return {\n      width: this.canvas.width,\n      height: this.canvas.height\n    };\n  }\n\n  // Returns a points x,y locations relative to the size of the canvase\n  getPointRelativeToCanvas(point) {\n    let precisionFactor = 100000;\n    let canvasSize = this.getCanvasSize();\n    return {\n      x: Math.round(point.x / canvasSize.width * precisionFactor) / precisionFactor,\n      y: Math.round(point.y / canvasSize.height * precisionFactor) / precisionFactor\n    };\n  }\n\n  isTouchEvent(e) {\n    return e.type.indexOf('touch') !== -1;\n  }\n\n  getCursorRelativeToCanvas(e) {\n    let cur = {};\n    let rect = this.canvas.getBoundingClientRect();\n\n    if (this.isTouchEvent(e)) {\n      cur.x = e.touches[0].pageX - rect.left;\n      cur.y = e.touches[0].pageY - rect.top;\n    } else {\n      cur.x = e.clientX - rect.left;\n      cur.y = e.clientY - rect.top;\n    }\n\n    return this.getPointRelativeToCanvas(cur);\n  }\n\n  getLineSizeRelativeToCanvas(size) {\n    let canvasSize = this.getCanvasSize();\n    return size / canvasSize.width;\n  }\n\n  /**\n   * Since points are stored relative to the size of the canvas\n   * this takes a point and converts it to actual x, y distances in the canvas\n  */\n  normalizePoint(x, y) {\n    var canvasSize = this.getCanvasSize();\n    return {\n      x: x * canvasSize.width,\n      y: y * canvasSize.height\n    };\n  }\n\n  /**\n   * Since line sizes are stored relative to the size of the canvas\n   * this takes a line size and converts it to a line size\n   * appropriate to the size of the canvas\n  */\n  normalizeLineSize(size) {\n    return size * this.getCanvasSize().width;\n  }\n\n  // Draw a stroke on the canvas\n  drawStroke(stroke) {\n    this.context.beginPath();\n    for (let i = 0; i < stroke.points.length - 1; i = i + 2) {\n      let start = this.normalizePoint(stroke.points[i], stroke.points[i + 1]);\n      let end = this.normalizePoint(stroke.points[i + 2], stroke.points[i + 3]);\n\n      this.context.moveTo(start.x, start.y);\n      this.context.lineTo(end.x, end.y);\n    }\n    this.context.closePath();\n\n    this.context.strokeStyle = stroke.color;\n    this.context.lineWidth = this.normalizeLineSize(stroke.size);\n    this.context.lineJoin = stroke.join;\n    this.context.lineCap = stroke.cap;\n    this.context.miterLimit = stroke.miterLimit;\n\n    this.context.stroke();\n  }\n\n  fullRedraw() {\n    map(this.users, (id, user) => {\n      user.lastPaintedIndex = 0;\n      this.redrawUser(user.id);\n    });\n  }\n\n  redraw() {\n    map(this.users, (id, user) => this.redrawUser(id));\n  }\n\n  redrawUser(userId) {\n    let user = this.users[userId];\n    let { strokes, lastPaintedIndex } = user;\n    let length = strokes.length;\n    if (!lastPaintedIndex) {\n      lastPaintedIndex = 0;\n    }\n\n    for (let i = lastPaintedIndex; i < length; i++) {\n      this.drawStroke(strokes[i]);\n    }\n    if (length === 0) {\n      user.lastPaintedIndex = 0;\n    } else {\n      user.lastPaintedIndex = length - 1;\n    }\n  }\n\n  // On mouse down, create a new stroke with a start location\n  startLine(e) {\n    e.preventDefault();\n    this.sketching = true;\n    this.undos = [];\n\n    let cursor = this.getCursorRelativeToCanvas(e);\n    this.users[this.userId].strokes.push({\n      points: [cursor.x, cursor.y],\n      color: this.opts.line.color,\n      size: this.getLineSizeRelativeToCanvas(this.opts.line.size),\n      cap: this.opts.line.cap,\n      join: this.opts.line.join,\n      miterLimit: this.opts.line.miterLimit\n    });\n  }\n\n  getEvents(event) {\n    return this.events[event] || [];\n  }\n\n  moveLine(e) {\n    if (!this.sketching) {\n      return;\n    }\n    e.preventDefault();\n\n    let cursor = this.getCursorRelativeToCanvas(e);\n    let lastStroke = this.lastStroke(this.userId);\n    let points = lastStroke.points;\n    points.push(cursor.x);\n    points.push(cursor.y);\n    this.redrawUser(this.userId);\n    this.eventBuffer = { stroke: lastStroke, event: e };\n  }\n\n  lastStroke(userId) {\n    let strokes = this.users[userId].strokes;\n    return strokes[strokes.length - 1];\n  }\n\n  endLine(e) {\n    if (!this.sketching) {\n      return;\n    }\n    e.preventDefault();\n\n    this.sketching = false;\n    let lastStroke = this.lastStroke(this.userId);\n    this.getEvents(\"stroke\").forEach(cb => cb(lastStroke));\n\n    // touchend events do not have a cursor position\n    if (this.isTouchEvent(e)) {\n      return;\n    }\n\n    let cursor = this.getCursorRelativeToCanvas(e);\n    lastStroke.points.push(cursor.x);\n    lastStroke.points.push(cursor.y);\n    this.redrawUser(this.userId);\n  }\n\n  undo() {\n    let strokes = this.users[this.userId];\n    if (strokes.length === 0) {\n      return;\n    }\n\n    this.undos.push(strokes.pop());\n    this.redrawUser(this.userId);\n  }\n\n  redo() {\n    if (this.undos.length === 0) {\n      return;\n    }\n    let strokes = this.users[this.userId];\n    strokes.push(this.undos.pop());\n    this.redrawUser(this.userId);\n  }\n\n  clear() {\n    let canvasSize = this.getCanvasSize();\n    this.undos = []; // TODO: Add clear action to undo\n    this.users = this.buildDefaultUsers(this.userId);\n    this.context.clearRect(0, 0, canvasSize.width, canvasSize.height);\n    this.redraw();\n  }\n\n  // Convert the sketchpad to a JSON object that can be loaded into\n  // other sketchpads or stored on a server\n  toJSON() {\n    let canvasSize = this.getCanvasSize();\n    return {\n      version: 1,\n      aspectRatio: canvasSize.width / canvasSize.height,\n      users: this.users\n    };\n  }\n\n  // Load a json object into the sketchpad\n  // @return {object} - JSON object to load\n  loadJSON(data) {\n    this.strokes = data.strokes;\n  }\n\n  // Get a static image element of the canvas\n  getImage() {\n    return '<img src=\"' + this.getImageURL() + '\"/>';\n  }\n\n  getImageURL() {\n    return this.canvas.toDataURL('image/png');\n  }\n\n  //Set the line size\n  // @param {number} size - Size of the brush\n  setLineSize(size) {\n    this.opts.line.size = size;\n  }\n\n  // Set the line color\n  // @param {string} color - Hexadecimal color code\n  setLineColor(color) {\n    this.opts.line.color = color;\n  }\n\n  putStroke(userId, stroke, lineOpts) {\n    setTimeout(() => {\n      stroke = mergeObjects(stroke, lineOpts);\n      if (!this.users[userId]) {\n        this.users[userId] = this.buildUser(userId);\n      }\n      this.users[userId].strokes.push(stroke);\n      this.redrawUser(userId);\n    }, 10);\n  }\n\n  // Resize the canvas maintaining original aspect ratio\n  // @param  {number} width - New width of the canvas\n  resize(width) {\n    let height = width * this.opts.aspectRatio;\n    this.opts.lineSize = this.opts.lineSize * (width / this.opts.width);\n    this.opts.width = width;\n    this.opts.height = height;\n\n    this.setCanvasSize(width, height);\n    this.fullRedraw();\n  }\n\n  on(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n  }\n}\n\n//# sourceURL=webpack:///./js/sketchpad.js?");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./js/app.js */\"./js/app.js\");\n\n\n//# sourceURL=webpack:///multi_./js/app.js?");

/***/ })

/******/ });